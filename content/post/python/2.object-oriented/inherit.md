---
title: Python inheritance
comments: true
toc: true
tags:
  - python
  - inheritance
description: 本文主要记录 Python 中的继承
categories:
  - python
  - object-oriented
date: 2020-03-22 22:12:48
---

# 继承

## 目标

- 单继承
- 多继承

## 面向对象三大特性

1. **封装**根据**职责**将**属性**和**方法**封装到一个抽象的类中
2. **继承**实现代码的重用，相同的代码不需要重复的编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

## 概念

子类拥有父类的所有方法和属性。

## 语法

```python
class 类名（父类名）
  pass
```

**子类**继承自**父类**，可以直接拥有父类的所有属性，并使用父类中已经封装好的方法，不需要再次开发

子类中应该根据**职责**，封装**子类特有的属性和方法**。

## 专业术语

Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类， Dog 类从 Animal 类继承 

Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生

## 继承的传递性

- C 类从 B 类继承，B 类又从 A 类继承

- 那么 C 类就具有 B 类和 A 类的所有属性和方法子类拥有`父类`以及`父类的父类`中封装的所有属性和方法

## 方法的重写

- 子类拥有父类的所有方法和属性

- 子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发

应用场景

- 当父类的方法实现不能满足子类需求时，可以对方法进行**重写（override）**

重写父类方法有两种情况：

1. 覆盖父类的方法
2. 对父类方法进行扩展

### 覆盖父类的方法

如果在开发中，父类的方法实现和子类的方法实现，完全不同, 就可以使用**覆盖**的方式，在子类中**重新编写**父类的方法实现

具体的实现方式，就相当于在**子类中**定义了ー个**和父类同名的方法并且实现重写**之后，在运行时，**只会调用**子类中重写的方法，而不再会调用**父类封装的方法**

### 对父类方法进行扩展

如果在开发中，子类的方法实现中包含父类的方法实现

- 父类原本封装的方法实现是子类方法的一部分

就可以使用**扩展**的方式

1. 在子类中**重写**父类的方法
2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
3. 代码其他的位置针对子类的需求，编写**子类特有的代码实现**

**关于 super**

- 在 Python 中 `super` 是一个**特殊的类**

- `super()` 就是使用 `super` 类创建出来的对象

- **最常**使用的场景就是在**重写父类方法时**，调用**在父类中封装的方法实现**

**调用父类方法的另外一种方式（知道）**

在 `Python2.x` 时，如果需要调用父类的方法，还可以使用以下方式：

```python
父类名.方法(self)
```

・这种方式，目前在 `Python3.x` 还支持这种方式

这种方法`不推荐使用`，因为一旦`父类发生变化`，方法调用位置的`类名`同样需要修改

提示

- 在开发时，`父类名`和 `super()` 两种方式不要混用

- 如果使用`当前子类名`调用方法，会形成递归调用，出现`死循环`

## 父类的私有属性和私有方法

1. **子类对象**不能在自己的方法内部，**直接**访问父类的**私有属性或私有方法**

2. **子类对象**可以通过**父类**的**公有方法****间接**访问到**私有属性**或**私有方法**

> - **私有属性、方法**是对象的隐私，不对外公开，**外界以及子类**都不能直接访问
> - **私有属性、方法**通常用于做一些内部的事情

# 多继承

- **子类**可以拥有**多个父类**，并且具有**所有父类**的**属性**和**方法**

- 例如：**孩子**会继承自己**父亲**和**母亲**的**特性**

多继承可以让子类对象，同时具有多个父类的属性和方法.

## 问题的提出

- 如果**不同的父类**中存在**同名的方法**，**子类对象**在调用方法时，会调用**哪一个父类**中的方法呢？

> 提示：**开发时，应该尽量避免这种容易产生混清的情况**！ーー如果**父类之间**存在**同名的属性或害方法**，应该**尽量避免**使用多继承

## Python 中的 MROーー方法搜索顺序（知道）

Python 中针对**类**提供了一个**内置属性**`__mro__`可以查看方法搜索顺序

`MRO` 是 `method resolution order`，主要用于在**多继承时判断方法、属性的调用路径**

```python
print(C.__mro__)
```

输入结果：

```python
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照 mro 的输出结果**从左至右**的顾序查找的
- 如果在当前类中**找到方法，就直接执行，不再搜素**
- 如果**没有找到，就查找下ー个类**中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

## 新式类与旧式（经典）类

> `objec ` 是 `Python` 为所有对象提供的**基类**，提供有一些内置的属性和方法，可以使用 `dir`函数查看

- 新式类：以 `object`为基类的类，推荐使用

- 经典类：不以 `object `为基类的类，不推荐使用

- 在 `Python3, x` 中定义类时，如果没有指定父类，会**默认使用** `object` 作为该类的**基类**.

  Python3, x 中定义的类都是新式类

- 在 `Python2.x` 中定义类时，如果没有指定父类，则不会以 `object`作为基类

> **新式类**和**经典类**在多继承时一一**会影响到方法的搜索顺序**

为了保证编写的代码能够同时在 Python2. X 和 Python3, X 运行！**今后在定义类时，如果没有父类，建议统一继承自 `object`**

```python
class 类名（object)
	pass
```